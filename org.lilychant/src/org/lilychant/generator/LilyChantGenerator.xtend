/*
 * generated by Xtext 2.9.2
 */
package org.lilychant.generator

import java.util.ArrayList
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import org.eclipse.xtext.nodemodel.util.NodeModelUtils
import org.lilychant.lilyChantScript.Barline
import org.lilychant.lilyChantScript.Chant
import org.lilychant.lilyChantScript.Note
import org.lilychant.lilyChantScript.Script
import org.lilychant.lilyChantScript.Tone
import org.lilychant.lilyChantScript.VoiceName
import org.lilychant.lilyChantScript.VoicePhrase

import static extension org.eclipse.xtext.EcoreUtil2.*
import org.lilychant.lilyChantScript.Syllable

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class LilyChantGenerator extends AbstractGenerator {
	
	def generateVoice(Tone tone) {
		'''
		«tone.name»
		'''
	}
		
	def private getVoiceNotes(Script model, Chant chant, VoiceName voiceName) {
		var currentPhraseIndex = -1
		var result = new ArrayList<String>()

		for (lyricPhrase : chant.phrases) {
			if (lyricPhrase.explicitPhrase != null) {
				currentPhraseIndex = chant.tone.phrases.indexOf(lyricPhrase.explicitPhrase)
			} else {
				currentPhraseIndex = (currentPhraseIndex+1) % chant.tone.phrases.length
				// Special case for 'final' phrase
				while (
					chant.tone.phrases.get(currentPhraseIndex).name.toLowerCase.endsWith("final")
					&& currentPhraseIndex != 0
				) {
					currentPhraseIndex = (currentPhraseIndex+1) % chant.tone.phrases.length
				}
			}
			val notePhrase = chant.tone.phrases.get(currentPhraseIndex)
			
			var VoicePhrase targetVoice
			for (voice : notePhrase.voices) {
				if (voice.name == voiceName) {
					targetVoice = voice
				}
			}
			
			// Match the notes to the syllables
			var noteIndex = 0
			for (noteGroup : lyricPhrase.noteGroups) {
				val syllables = noteGroup.syllables.filter[!#['_', '__', '--'].contains(literal)]
				var insideGroup = false
				
				// Print the notes
				var syllableIndex = 0
				var inSlur = false
				var emphasisAdded = false
				while (syllableIndex < noteGroup.syllables.length) {
					
					// TODO use terminal definitions for hyphens and extenders, but where do they live?
					// TODO Better error handling
					try {
						val note = targetVoice.notes.get(noteIndex)
						val syllable = noteGroup.syllables.get(syllableIndex)
						switch (syllable.literal) {
							case "--",
							case "_": {
								// skip to the next syllable
							}
							case "__": {
								if (doGroupSyllables(syllables.length)) {
									// error
								} else {
									if (!inSlur) {
										while (result.last.contains('bar')) {
											result.remove(result.last)
										}
										result.add("(")
										inSlur = true
									}
									// slurring implies advance to the next note,
									// *unless* it's the first of a note-group, in which case
									// the advance has already happened!
									if (syllableIndex > 0)
										noteIndex++
									
									// This adds the actual note:
									val nextNote = targetVoice.notes.get(noteIndex)
									result.add(nextNote.toLyString)
									
									if (syllableIndex+1 == noteGroup.syllables.length
											|| noteGroup.syllables.get(syllableIndex+1).literal != "__")
										result.add(")")
								}
							}
							default: {
								if (inSlur) {
									result.add(")")
									inSlur = false
								}

								if (doGroupSyllables(syllables.length)) {
									if (syllableIndex == 0) {
										// First and last of the group get their own notes
										result.add(note.toLyString)
									} else if (syllableIndex==1 && noteGroup.syllables.get(0).literal=='--') {
										// First and last of the group get their own notes
										result.add(note.toLyString)
									} else if (syllableIndex == noteGroup.syllables.length-1) {
										// First and last of the group get their own notes
										result.add(note.toLyString)
										result.add('''\bar ""''')
										insideGroup = false
									} else if (!insideGroup) {
										// Print the group 'breve' note
										result.add(note.pitch + '''\breve''')
										insideGroup = true
									} else {
										// No new note: falls under the previous breve
									}
								} else {
									// This adds the actual note:
									if (noteGroup.noemphasis) {
										// enforce no emphasis in this group
										// (even if the note in the tone specifies it!)
										result.add(note.pitch + '4')
									} else if (syllable.emphasis && !emphasisAdded) {
										// emphasis on this syllable in the group ('*')
										result.add(note.pitch + '2')
										emphasisAdded = true
									} else if (emphasisAdded) {
										if (syllableIndex==noteGroup.syllables.length-1
											&& noteGroup===lyricPhrase.noteGroups.last) {
											// this is the last syllable in the phrase.
											// Even though emphasis has been added, this one needs to be long 
											result.add(note.pitch + '2')
										} else {
											// emphasis is already added, so make this one short
											result.add(note.pitch + '4')
										}
									} else
										// no emphasis requested, and none applied previously
										result.add(note.toLyString)
									result.add('''\bar ""''')
								}
							}
						}
					} catch (IndexOutOfBoundsException e) {
						System.err.println('''
							More syllabels than notes! («noteIndex» >= «targetVoice.notes.length»)
							  Phrase: «notePhrase.name»
							  Line: «NodeModelUtils.getNode(noteGroup).startLine»
						''')
						throw e
					}
					syllableIndex++
				}
				syllableIndex++
				noteIndex++
			}
			switch (lyricPhrase.bar) {
				case Barline.SINGLE: {
					result.add('''\bar "|"''')
					result.add('\n')
				}
				case Barline.DOUBLE: {
					result.add('''\bar "||"''')
					result.add('\n')
				}
			}
		}
		
		result.add('''\bar "|."''')
		
//		println('''Notes for voice: «FOR note : result» «note»«ENDFOR»''')
		return result
	}

	def private generateVoices(Script model, Chant chant) {
		'''
		«FOR voice : chant.tone.voiceNames»
		«voice.name» = {
			«FOR note : getVoiceNotes(model, chant, voice)»«note» «ENDFOR»
		}
		
		«ENDFOR»
		'''
	}
	
	def private generateLyrics(Script model, Chant chant) {
		var result = new StringBuilder('''
			words = \lyricmode {
		''')
		
		for (lyricPhrase : chant.phrases) {
			for (noteGroup : lyricPhrase.noteGroups) {
				val printSyllables = noteGroup.syllables.filter[!#['_'].contains(literal)]
				val lyricSyllables = noteGroup.syllables.filter[!#['_', '__', '--'].contains(literal)]
				
				// "_" implies a skipped note in the NotePhrase
				// TODO Don't use a string literal!
				result.append('\t')
				
				if (doGroupSyllables(lyricSyllables.length)) {
					// Group all but the first and last syllables into a single quoted string
					
					var sylIdx = 0

					// First syllable
					do {
						result.append(' ')
						result.append(printSyllables.get(sylIdx).toLyString)
						sylIdx++
					} while (printSyllables.get(sylIdx-1).literal == '--')
					
					// Middle syllables
					result.append(' "')
					while (sylIdx < printSyllables.length-1) {
						if (printSyllables.get(sylIdx).literal != '--') {
							result.append(printSyllables.get(sylIdx).toLyString)
							if (printSyllables.get(sylIdx+1).literal != '--') {
								// next is a new word
								result.append(' ')
							}
						}
						sylIdx++
					}
					result.append('" ')
					
					// Last
					if (printSyllables.get(sylIdx).literal == '--') {
						result.append(' --')
					}
					result.append(printSyllables.last.toLyString)

				} else {
					for (syllable : printSyllables) {
						result.append(syllable.toLyString)
						result.append(' ')
					}
				}
				result.append('\n')
			}
		}
		
		result.append('''
			}
		''')
		
		return result.toString
	}
	
	def private toLyString(Note it) {
		return '''«pitch»«IF duration!=""»«duration»«ENDIF»'''
	}
	
	def private toLyString(Syllable it) {
		if (literal == '__')
			// Don't print vocal extenders
			return ''
		else
			return literal
	}
	
	def private doGroupSyllables(int numSyllables) {
		return (numSyllables >=5)
	}

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		val model = resource.allContents.filter(typeof(Script)).next
		
		// Only generate if there are chants in the file
		if (model.chants.size == 0)
			return
		
		val filename = resource.normalizedURI.lastSegment + ".ly"
		fsa.generateFile(filename,
			'''
			\version "2.16.2"
			
			% =======================
			% Global Variables
			% =======================
			alignleft = \once \override LyricText #'self-alignment-X = #-1
			
			«FOR chant : model.chants»
			«IF chant.name != null»
			% =======================
			% Score «IF chant.name != null»for «chant.name»«ENDIF»
			% =======================
			«ENDIF»
			%
			% voices
			%
			«model.generateVoices(chant)»
			
			% =======================
			% Lyrics
			% =======================
			«model.generateLyrics(chant)»
			
			«IF chant.name != null»
			  \header { title = "«chant.name»" }
			«ENDIF»

			\score {
			  \new ChoirStaff \with {
			    instrumentName = \markup \bold "Choir:"
			  }
			  <<
			    #(set-accidental-style 'neo-modern 'Score)
			    \new Staff {
			      \key g \major
			      \cadenzaOn
			      <<{
				  \new Voice = "Sop" {
				    %\voiceOne
				    \Sop
				  }
				}>>
			    }
			    \new Lyrics \lyricsto "Sop" { \words }
			    \new Staff {
			      \key g \major
			      \clef bass
			      \cadenzaOn
			      <<{
				  \new Voice = "Bass" {
				    %\voiceOne
				    \Bass
				  }
				}>>
			    }
			  >>
			}
			
			«ENDFOR»
			
			% =======================
			% Layout
			% =======================
			\paper { ragged-last-bottom = ##f }

			\layout {
			  \context {
			    \Score
			    \remove "Bar_number_engraver"
			  }
			  \context {
			    \Staff
			    \remove "Time_signature_engraver"
			  }
			}			
			'''.toString
		)
	}
}
